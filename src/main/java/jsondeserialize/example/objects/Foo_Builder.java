// Autogenerated code. Do not modify.
package jsondeserialize.example.objects;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import java.util.EnumSet;
import java.util.Objects;
import java.util.function.DoubleUnaryOperator;
import java.util.function.IntUnaryOperator;
import java.util.function.UnaryOperator;
import javax.annotation.Generated;

/** Auto-generated superclass of {@link Foo.Builder}, derived from the API of {@link Foo}. */
@Generated("org.inferred.freebuilder.processor.Processor")
abstract class Foo_Builder {

  /**
   * Creates a new builder using {@code value} as a template.
   *
   * <p>If {@code value} is a partial, the builder will return more partials.
   */
  public static Foo.Builder from(Foo value) {
    if (value instanceof Rebuildable) {
      return ((Rebuildable) value).toBuilder();
    } else {
      return new Foo.Builder().mergeFrom(value);
    }
  }

  private enum Property {
    FOOS_INT("foosInt"),
    FOOS_STRING("foosString"),
    FOOS_DOUBLE("foosDouble"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private int foosInt;
  private String foosString;
  private double foosDouble;
  private final EnumSet<Property> _unsetProperties = EnumSet.allOf(Property.class);

  /**
   * Sets the value to be returned by {@link Foo#foosInt()}.
   *
   * @return this {@code Builder} object
   */
  @JsonProperty("foosInt")
  public Foo.Builder foosInt(int foosInt) {
    this.foosInt = foosInt;
    _unsetProperties.remove(Property.FOOS_INT);
    return (Foo.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Foo#foosInt()} by applying {@code mapper} to it and
   * using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   * @throws IllegalStateException if the field has not been set
   */
  public Foo.Builder mapFoosInt(IntUnaryOperator mapper) {
    Objects.requireNonNull(mapper);
    return foosInt(mapper.applyAsInt(foosInt()));
  }

  /**
   * Returns the value that will be returned by {@link Foo#foosInt()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public int foosInt() {
    Preconditions.checkState(!_unsetProperties.contains(Property.FOOS_INT), "foosInt not set");
    return foosInt;
  }

  /**
   * Sets the value to be returned by {@link Foo#foosString()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code foosString} is null
   */
  @JsonProperty("foosString")
  public Foo.Builder foosString(String foosString) {
    this.foosString = Objects.requireNonNull(foosString);
    _unsetProperties.remove(Property.FOOS_STRING);
    return (Foo.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Foo#foosString()} by applying {@code mapper} to it
   * and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Foo.Builder mapFoosString(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return foosString(mapper.apply(foosString()));
  }

  /**
   * Returns the value that will be returned by {@link Foo#foosString()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String foosString() {
    Preconditions.checkState(
        !_unsetProperties.contains(Property.FOOS_STRING), "foosString not set");
    return foosString;
  }

  /**
   * Sets the value to be returned by {@link Foo#foosDouble()}.
   *
   * @return this {@code Builder} object
   */
  @JsonProperty("foosDouble")
  public Foo.Builder foosDouble(double foosDouble) {
    this.foosDouble = foosDouble;
    _unsetProperties.remove(Property.FOOS_DOUBLE);
    return (Foo.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Foo#foosDouble()} by applying {@code mapper} to it
   * and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   * @throws IllegalStateException if the field has not been set
   */
  public Foo.Builder mapFoosDouble(DoubleUnaryOperator mapper) {
    Objects.requireNonNull(mapper);
    return foosDouble(mapper.applyAsDouble(foosDouble()));
  }

  /**
   * Returns the value that will be returned by {@link Foo#foosDouble()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public double foosDouble() {
    Preconditions.checkState(
        !_unsetProperties.contains(Property.FOOS_DOUBLE), "foosDouble not set");
    return foosDouble;
  }

  /**
   * Copies values from {@code value}.
   *
   * @return this {@code Builder} object
   */
  public Foo.Builder mergeFrom(Foo value) {
    Foo_Builder defaults = new Foo.Builder();
    if (defaults._unsetProperties.contains(Property.FOOS_INT)
        || value.foosInt() != defaults.foosInt()) {
      foosInt(value.foosInt());
    }
    if (defaults._unsetProperties.contains(Property.FOOS_STRING)
        || !Objects.equals(value.foosString(), defaults.foosString())) {
      foosString(value.foosString());
    }
    if (defaults._unsetProperties.contains(Property.FOOS_DOUBLE)
        || Double.doubleToLongBits(value.foosDouble())
            != Double.doubleToLongBits(defaults.foosDouble())) {
      foosDouble(value.foosDouble());
    }
    return (Foo.Builder) this;
  }

  /**
   * Copies values from {@code template}, skipping unset properties.
   *
   * @return this {@code Builder} object
   */
  public Foo.Builder mergeFrom(Foo.Builder template) {
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    Foo_Builder base = template;
    Foo_Builder defaults = new Foo.Builder();
    if (!base._unsetProperties.contains(Property.FOOS_INT)
        && (defaults._unsetProperties.contains(Property.FOOS_INT)
            || template.foosInt() != defaults.foosInt())) {
      foosInt(template.foosInt());
    }
    if (!base._unsetProperties.contains(Property.FOOS_STRING)
        && (defaults._unsetProperties.contains(Property.FOOS_STRING)
            || !Objects.equals(template.foosString(), defaults.foosString()))) {
      foosString(template.foosString());
    }
    if (!base._unsetProperties.contains(Property.FOOS_DOUBLE)
        && (defaults._unsetProperties.contains(Property.FOOS_DOUBLE)
            || Double.doubleToLongBits(template.foosDouble())
                != Double.doubleToLongBits(defaults.foosDouble()))) {
      foosDouble(template.foosDouble());
    }
    return (Foo.Builder) this;
  }

  /**
   * Resets the state of this builder.
   *
   * @return this {@code Builder} object
   */
  public Foo.Builder clear() {
    Foo_Builder defaults = new Foo.Builder();
    foosInt = defaults.foosInt;
    foosString = defaults.foosString;
    foosDouble = defaults.foosDouble;
    _unsetProperties.clear();
    _unsetProperties.addAll(defaults._unsetProperties);
    return (Foo.Builder) this;
  }

  /**
   * Returns a newly-created {@link Foo} based on the contents of this {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public Foo build() {
    Preconditions.checkState(_unsetProperties.isEmpty(), "Not set: %s", _unsetProperties);
    return new Value(this);
  }

  /**
   * Returns a newly-created partial {@link Foo} for use in unit tests. State checking will not be
   * performed. Unset properties will throw an {@link UnsupportedOperationException} when accessed
   * via the partial object.
   *
   * <p>The builder returned by {@link Foo.Builder#from(Foo)} will propagate the partial status of
   * its input, overriding {@link Foo.Builder#build() build()} to return another partial. This
   * allows for robust tests of modify-rebuild code.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  @VisibleForTesting()
  public Foo buildPartial() {
    return new Partial(this);
  }

  private abstract static class Rebuildable implements Foo {
    public abstract Builder toBuilder();
  }

  private static final class Value extends Rebuildable {
    private final int foosInt;
    private final String foosString;
    private final double foosDouble;

    private Value(Foo_Builder builder) {
      this.foosInt = builder.foosInt;
      this.foosString = builder.foosString;
      this.foosDouble = builder.foosDouble;
    }

    @Override
    @JsonProperty("foosInt")
    public int foosInt() {
      return foosInt;
    }

    @Override
    @JsonProperty("foosString")
    public String foosString() {
      return foosString;
    }

    @Override
    @JsonProperty("foosDouble")
    public double foosDouble() {
      return foosDouble;
    }

    @Override
    public Builder toBuilder() {
      Foo_Builder builder = new Builder();
      builder.foosInt = foosInt;
      builder.foosString = foosString;
      builder.foosDouble = foosDouble;
      builder._unsetProperties.clear();
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Value)) {
        return false;
      }
      Value other = (Value) obj;
      return foosInt == other.foosInt
          && Objects.equals(foosString, other.foosString)
          && Double.doubleToLongBits(foosDouble) == Double.doubleToLongBits(other.foosDouble);
    }

    @Override
    public int hashCode() {
      return Objects.hash(foosInt, foosString, foosDouble);
    }

    @Override
    public String toString() {
      return "Foo{foosInt="
          + foosInt
          + ", foosString="
          + foosString
          + ", foosDouble="
          + foosDouble
          + "}";
    }
  }

  private static final class Partial extends Rebuildable {
    private final int foosInt;
    private final String foosString;
    private final double foosDouble;
    private final EnumSet<Property> _unsetProperties;

    Partial(Foo_Builder builder) {
      this.foosInt = builder.foosInt;
      this.foosString = builder.foosString;
      this.foosDouble = builder.foosDouble;
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    @JsonProperty("foosInt")
    public int foosInt() {
      if (_unsetProperties.contains(Property.FOOS_INT)) {
        throw new UnsupportedOperationException("foosInt not set");
      }
      return foosInt;
    }

    @Override
    @JsonProperty("foosString")
    public String foosString() {
      if (_unsetProperties.contains(Property.FOOS_STRING)) {
        throw new UnsupportedOperationException("foosString not set");
      }
      return foosString;
    }

    @Override
    @JsonProperty("foosDouble")
    public double foosDouble() {
      if (_unsetProperties.contains(Property.FOOS_DOUBLE)) {
        throw new UnsupportedOperationException("foosDouble not set");
      }
      return foosDouble;
    }

    private static class PartialBuilder extends Builder {
      @Override
      public Foo build() {
        return buildPartial();
      }
    }

    @Override
    public Builder toBuilder() {
      Foo_Builder builder = new PartialBuilder();
      builder.foosInt = foosInt;
      builder.foosString = foosString;
      builder.foosDouble = foosDouble;
      builder._unsetProperties.clear();
      builder._unsetProperties.addAll(_unsetProperties);
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Partial)) {
        return false;
      }
      Partial other = (Partial) obj;
      return foosInt == other.foosInt
          && Objects.equals(foosString, other.foosString)
          && Double.doubleToLongBits(foosDouble) == Double.doubleToLongBits(other.foosDouble)
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(foosInt, foosString, foosDouble, _unsetProperties);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial Foo{");
      String separator = "";
      if (!_unsetProperties.contains(Property.FOOS_INT)) {
        result.append("foosInt=").append(foosInt);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.FOOS_STRING)) {
        result.append(separator).append("foosString=").append(foosString);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.FOOS_DOUBLE)) {
        result.append(separator).append("foosDouble=").append(foosDouble);
      }
      return result.append("}").toString();
    }
  }
}
